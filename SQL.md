# [一些知识](readme.md#数据库相关)

# 事务

多条 SQL 语句作为整体进行操作的功能，称为事务。

事务中的操作要么全部执行成功，要么全部失败。

事务的四个特性：

* A(tomic)：原子性，事务作为原子单位，要么全部执行，要么全部不执行
* C(onsistent)：一致性，事务完成后，所有数据的状态是一致的
* I(solation)：隔离性，并发的多个事务间的修改必须相互隔离
* D(uration)：持久性，事务完成后，数据的修改要持久化存储

## 隔离级别

**多个并发执行**的事务，涉及操作**同一条记录**的时候，需要针对性选择不同的隔离级别， 避免数据不一致

| Isolation Level NAME                  | Isolation Level | 导致[脏读（Dirty Read）](#脏读)？ | 导致[不可重复读（Non Repeatable Read）](#不可重复读)？ | 导致[幻读（Phantom Read）](#幻读)？ |
| :------------------------------------ | :-------------: | :-------------------------------: | :----------------------------------------------------: | :---------------------------------: |
| [Read Uncommitted](#Read Uncommitted) |        1        |                Yes                |                          Yes                           |                 Yes                 |
| [Read Committed](#Read Committed)     |        2        |                 -                 |                          Yes                           |                 Yes                 |
| [Repeatable Read](#Repeatable Read)   |        3        |                 -                 |                           -                            |                 Yes                 |
| [Serializable](#Serializable)         |        4        |                 -                 |                           -                            |                  -                  |

> 隔离级别越低，越容易导致数据不一致

* ### Read Uncommitted

可理解为：读到了另一个事务未提交的数据

* ### Read Committed

可理解为：读到了另一个事务提交的数据，导致前后数据不一致

* ### Repeatable Read

可理解为：一开始读不到存在的数据，之后能读到

* ### Serializable

可理解为：所有事务串行执行

效率会大大下降，应用程序的性能会急剧降低

### 数据不一致现象

* #### 脏读

最低的一种事务级别。在这种隔离级别下，A 事务会读到 B 事务更新后但未提交的数据，如果 B 事务回滚，那么 A 事务读到的数据就是脏数据，这就是脏读（Dirty Read）

* #### 不可重复读

多次读取同一数据，数据前后不一致

* #### 幻读

事务 A 修改数据后，事务 B 读不到数据，但可以更新数据，之后就可以再次读取了